<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹éƒ¨è¿½è¸ªå£è™åŠ¨ç”»</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #282c34; }
        canvas { display: block; }
        .info {
            position: fixed; bottom: 20px; left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        #video-container {
            position: fixed;
            top: 20px;
            right: 20px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        #video {
            width: 240px;
            height: 180px;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }
        .status {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
        }
        .status.loading { color: #ffd700; }
        .status.ready { color: #4ade80; }
        .status.error { color: #f87171; }
        .toggle-btn {
            position: fixed;
            top: 210px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
            transition: background 0.2s;
        }
        .toggle-btn:hover { background: rgba(255, 255, 255, 0.2); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="video-container">
        <video id="video" autoplay playsinline></video>
    </div>
    <button class="toggle-btn" onclick="toggleVideo()">éšè—æ‘„åƒå¤´</button>
    <div class="status loading" id="status">æ­£åœ¨åŠ è½½æ‰‹éƒ¨è¿½è¸ªæ¨¡å‹...</div>
    <div class="info">ç”¨æ‰‹æ§åˆ¶å£è™çš„çˆ¬è¡Œæ–¹å‘ | é è¿‘å°è™«ä¼šè‡ªåŠ¨æ•é£Ÿ</div>

    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ==================== å·¥å…·å‡½æ•° ====================
        function simplifyAngle(angle) {
            while (angle >= Math.PI * 2) angle -= Math.PI * 2;
            while (angle < 0) angle += Math.PI * 2;
            return angle;
        }

        function relativeAngleDiff(angle, anchor) {
            angle = simplifyAngle(angle + Math.PI - anchor);
            return Math.PI - angle;
        }

        function constrainAngle(angle, anchor, constraint) {
            if (Math.abs(relativeAngleDiff(angle, anchor)) <= constraint) return simplifyAngle(angle);
            if (relativeAngleDiff(angle, anchor) > constraint) return simplifyAngle(anchor - constraint);
            return simplifyAngle(anchor + constraint);
        }

        function constrainDistance(pos, anchor, constraint) {
            const dx = pos.x - anchor.x, dy = pos.y - anchor.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return { x: anchor.x + constraint, y: anchor.y };
            return { x: anchor.x + (dx / dist) * constraint, y: anchor.y + (dy / dist) * constraint };
        }

        function vecAdd(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
        function vecSub(a, b) { return { x: a.x - b.x, y: a.y - b.y }; }
        function vecMag(v) { return Math.sqrt(v.x * v.x + v.y * v.y); }
        function vecSetMag(v, mag) {
            const m = vecMag(v);
            if (m === 0) return { x: mag, y: 0 };
            return { x: (v.x / m) * mag, y: (v.y / m) * mag };
        }
        function vecHeading(v) { return Math.atan2(v.y, v.x); }
        function vecFromAngle(angle, mag = 1) { return { x: Math.cos(angle) * mag, y: Math.sin(angle) * mag }; }
        function vecDist(a, b) { return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2); }
        function vecLerp(a, b, t) { return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t }; }

        // ==================== å°è™«ç±» ====================
        class Bug {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.spawn();
            }
            
            spawn() {
                // ä»ç”»é¢è¾¹ç¼˜éšæœºä½ç½®ç”Ÿæˆ
                const side = Math.floor(Math.random() * 4);
                const margin = 30;
                switch(side) {
                    case 0: // ä¸Š
                        this.x = Math.random() * this.width;
                        this.y = -margin;
                        break;
                    case 1: // å³
                        this.x = this.width + margin;
                        this.y = Math.random() * this.height;
                        break;
                    case 2: // ä¸‹
                        this.x = Math.random() * this.width;
                        this.y = this.height + margin;
                        break;
                    case 3: // å·¦
                        this.x = -margin;
                        this.y = Math.random() * this.height;
                        break;
                }
                
                // å‘ç”»é¢ä¸­å¿ƒåŒºåŸŸç§»åŠ¨çš„åˆå§‹æ–¹å‘
                const centerX = this.width / 2 + (Math.random() - 0.5) * this.width * 0.6;
                const centerY = this.height / 2 + (Math.random() - 0.5) * this.height * 0.6;
                this.angle = Math.atan2(centerY - this.y, centerX - this.x);
                this.speed = 1 + Math.random() * 1.5;
                this.wobble = 0;
                this.wobbleSpeed = 0.05 + Math.random() * 0.05;
                this.size = 4 + Math.random() * 3;
                
                // èº«ä½“å‚æ•°
                this.segments = 4;
                this.segmentPos = [];
                for (let i = 0; i < this.segments; i++) {
                    this.segmentPos.push({ x: this.x - i * 5, y: this.y });
                }
                
                // è¢«æ•é£ŸçŠ¶æ€
                this.caught = false;
                this.caughtProgress = 0;
                this.caughtBy = null;
                this.alive = true;
            }
            
            update() {
                if (this.caught) {
                    // è¢«èˆŒå¤´æŠ“ä½ï¼Œå‘å£è™å¤´éƒ¨ç§»åŠ¨
                    this.caughtProgress += 0.03; // æ”¾æ…¢æ‹–å…¥é€Ÿåº¦
                    if (this.caughtProgress >= 1) {
                        this.alive = false; // è¢«åƒæ‰
                    }
                    return;
                }
                
                // éšæœºæ‘†åŠ¨
                this.wobble += this.wobbleSpeed;
                const wobbleAngle = Math.sin(this.wobble) * 0.3;
                
                // å¶å°”æ”¹å˜æ–¹å‘
                if (Math.random() < 0.02) {
                    this.angle += (Math.random() - 0.5) * Math.PI / 2;
                }
                
                // ç§»åŠ¨å¤´éƒ¨
                const moveAngle = this.angle + wobbleAngle;
                this.x += Math.cos(moveAngle) * this.speed;
                this.y += Math.sin(moveAngle) * this.speed;
                
                // æ›´æ–°èº«ä½“æ®µ
                this.segmentPos[0] = { x: this.x, y: this.y };
                for (let i = 1; i < this.segments; i++) {
                    const prev = this.segmentPos[i - 1];
                    const curr = this.segmentPos[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const segDist = this.size * 1.2;
                    if (dist > segDist) {
                        const ratio = segDist / dist;
                        this.segmentPos[i] = {
                            x: prev.x + dx * ratio,
                            y: prev.y + dy * ratio
                        };
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦ç¦»å¼€ç”»é¢å¤ªè¿œ
                const margin = 100;
                if (this.x < -margin || this.x > this.width + margin ||
                    this.y < -margin || this.y > this.height + margin) {
                    this.spawn();
                }
            }
            
            draw(ctx, gecko) {
                if (!this.alive) return;
                
                let drawX = this.x, drawY = this.y;
                
                if (this.caught && this.caughtBy) {
                    // è¢«æŠ“ä½æ—¶ï¼Œä½ç½®åœ¨èˆŒå°–å’Œå¤´éƒ¨ä¹‹é—´æ’å€¼
                    const headAngle = this.caughtBy.spine.angles[0];
                    const headPos = this.caughtBy.spine.joints[0];
                    const headTip = {
                        x: headPos.x + Math.cos(headAngle) * 45,
                        y: headPos.y + Math.sin(headAngle) * 45
                    };
                    const tongueEnd = {
                        x: headPos.x + Math.cos(headAngle) * (35 + 35),
                        y: headPos.y + Math.sin(headAngle) * (35 + 35)
                    };
                    
                    // ä»èˆŒå°–å‘å¤´éƒ¨ç§»åŠ¨
                    drawX = tongueEnd.x + (headTip.x - tongueEnd.x) * this.caughtProgress;
                    drawY = tongueEnd.y + (headTip.y - tongueEnd.y) * this.caughtProgress;
                    
                    // æ›´æ–°æ‰€æœ‰æ®µçš„ä½ç½®
                    for (let i = 0; i < this.segments; i++) {
                        this.segmentPos[i] = { x: drawX, y: drawY };
                    }
                }
                
                // ç»˜åˆ¶å°è™«èº«ä½“ï¼ˆç™½è‰²ï¼‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < this.segments; i++) {
                    const pos = this.segmentPos[i];
                    const segSize = this.size * (1 - i * 0.15);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, segSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å°è…¿ï¼ˆå¦‚æœæ²¡è¢«æŠ“ï¼‰
                if (!this.caught) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1.5;
                    const legWave = Math.sin(this.wobble * 3);
                    for (let i = 0; i < 3; i++) {
                        const segPos = this.segmentPos[Math.min(i, this.segments - 1)];
                        const legAngle1 = this.angle + Math.PI / 2 + legWave * 0.3;
                        const legAngle2 = this.angle - Math.PI / 2 - legWave * 0.3;
                        const legLen = this.size * 1.5;
                        
                        ctx.beginPath();
                        ctx.moveTo(segPos.x, segPos.y);
                        ctx.lineTo(segPos.x + Math.cos(legAngle1) * legLen, segPos.y + Math.sin(legAngle1) * legLen);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(segPos.x, segPos.y);
                        ctx.lineTo(segPos.x + Math.cos(legAngle2) * legLen, segPos.y + Math.sin(legAngle2) * legLen);
                        ctx.stroke();
                    }
                }
            }
            
            getPosition() {
                return { x: this.x, y: this.y };
            }
        }

        // ==================== é“¾å¼éª¨éª¼ç³»ç»Ÿ ====================
        class Chain {
            constructor(origin, jointCount, linkSize, angleConstraint = Math.PI * 2) {
                this.linkSize = linkSize;
                this.angleConstraint = angleConstraint;
                this.joints = [];
                this.angles = [];
                const initialAngle = -Math.PI / 2;
                this.joints.push({ x: origin.x, y: origin.y });
                this.angles.push(initialAngle);
                for (let i = 1; i < jointCount; i++) {
                    this.joints.push({
                        x: this.joints[i - 1].x - Math.cos(initialAngle) * this.linkSize,
                        y: this.joints[i - 1].y - Math.sin(initialAngle) * this.linkSize
                    });
                    this.angles.push(initialAngle);
                }
            }

            resolve(pos) {
                const headDiff = vecSub(pos, this.joints[0]);
                const headDist = vecMag(headDiff);
                if (headDist < 0.5) return;
                this.angles[0] = vecHeading(headDiff);
                this.joints[0] = { x: pos.x, y: pos.y };
                for (let i = 1; i < this.joints.length; i++) {
                    const diff = vecSub(this.joints[i - 1], this.joints[i]);
                    if (vecMag(diff) > 0.5) {
                        this.angles[i] = constrainAngle(vecHeading(diff), this.angles[i - 1], this.angleConstraint);
                    }
                    const offset = vecFromAngle(this.angles[i], this.linkSize);
                    this.joints[i] = vecSub(this.joints[i - 1], offset);
                }
            }

            fabrikResolve(pos, anchor) {
                const footDist = vecMag(vecSub(pos, this.joints[0]));
                const anchorDist = vecMag(vecSub(anchor, this.joints[this.joints.length - 1]));
                if (footDist < 0.5 && anchorDist < 0.5) return;
                this.joints[0] = { x: pos.x, y: pos.y };
                for (let i = 1; i < this.joints.length; i++) {
                    this.joints[i] = constrainDistance(this.joints[i], this.joints[i - 1], this.linkSize);
                }
                this.joints[this.joints.length - 1] = { x: anchor.x, y: anchor.y };
                for (let i = this.joints.length - 2; i >= 0; i--) {
                    this.joints[i] = constrainDistance(this.joints[i], this.joints[i + 1], this.linkSize);
                }
            }
        }

        // ==================== å£è™ç±» ====================
        class Gecko {
            constructor(origin) {
                this.spine = new Chain(origin, 14, 50, Math.PI / 8);
                this.bodyWidth = [42, 48, 34, 50, 56, 58, 52, 40, 22, 12, 9, 7, 5, 5];
                this.legs = [];
                this.legTargets = [];
                for (let i = 0; i < 4; i++) {
                    this.legs.push(new Chain(origin, 3, i < 2 ? 42 : 32));
                    const side = i % 2 === 0 ? 1 : -1;
                    const bodyIndex = i < 2 ? 3 : 7;
                    const angle = i < 2 ? Math.PI / 4 : Math.PI / 3;
                    this.legTargets.push({ x: this.getPosX(bodyIndex, angle * side, 70), y: this.getPosY(bodyIndex, angle * side, 70) });
                }
                this.bodyColor = '#8BC48A';
                this.legColor = '#8BC48A';
                this.tongueOut = 0;
                this.tongueTarget = 0;
                this.tongueTimer = 0;
                this.tongueColor = '#FFB6C1';
                this.scheduleNextTongue();
                this.initialized = false;
                
                // æ•é£Ÿç›¸å…³
                this.huntingTarget = null;
                this.isHunting = false;
            }
            
            scheduleNextTongue() { this.tongueTimer = 120 + Math.random() * 240; }
            
            // æ£€æµ‹å¹¶æ•é£Ÿå°è™«
            checkForPrey(bugs) {
                if (this.isHunting || this.tongueOut > 0) return; // æ­£åœ¨æ•é£Ÿä¸­
                
                const headAngle = this.spine.angles[0];
                const headPos = this.spine.joints[0];
                const headTip = {
                    x: headPos.x + Math.cos(headAngle) * 45,
                    y: headPos.y + Math.sin(headAngle) * 45
                };
                
                for (const bug of bugs) {
                    if (bug.caught || !bug.alive) continue;
                    
                    const bugPos = bug.getPosition();
                    const dist = vecDist(headTip, bugPos);
                    
                    // æ£€æµ‹è·ç¦»å’Œè§’åº¦
                    if (dist < 100) {
                        const angleToBug = Math.atan2(bugPos.y - headTip.y, bugPos.x - headTip.x);
                        const angleDiff = Math.abs(relativeAngleDiff(angleToBug, headAngle));
                        
                        if (angleDiff < Math.PI / 4) { // åœ¨æ­£å‰æ–¹60åº¦èŒƒå›´å†…
                            this.huntingTarget = bug;
                            this.isHunting = true;
                            this.tongueTarget = 1; // ä¼¸å‡ºèˆŒå¤´
                            return;
                        }
                    }
                }
            }
            
            updateTongue() {
                this.tongueTimer--;
                
                // éšæœºåèˆŒå¤´ï¼ˆéæ•é£ŸçŠ¶æ€ï¼‰
                if (this.tongueTimer <= 0 && this.tongueTarget === 0 && this.tongueOut === 0 && !this.isHunting) {
                    this.tongueTarget = 1;
                }
                
                if (this.tongueTarget === 1) {
                    this.tongueOut += 0.08; // èˆŒå¤´ä¼¸å‡ºé€Ÿåº¦
                    if (this.tongueOut >= 1) { 
                        this.tongueOut = 1; 
                        this.tongueTarget = -1;
                        
                        // æ•è·çŒç‰©
                        if (this.isHunting && this.huntingTarget) {
                            this.huntingTarget.caught = true;
                            this.huntingTarget.caughtBy = this;
                        }
                    }
                } else if (this.tongueTarget === -1) {
                    this.tongueOut -= 0.05; // èˆŒå¤´æ”¶å›é€Ÿåº¦ï¼ˆæ›´æ…¢ï¼Œçœ‹æ¸…å°è™«è¢«æ‹–å…¥ï¼‰
                    if (this.tongueOut <= 0) { 
                        this.tongueOut = 0; 
                        this.tongueTarget = 0; 
                        this.scheduleNextTongue();
                        
                        // å®Œæˆæ•é£Ÿ
                        this.isHunting = false;
                        this.huntingTarget = null;
                    }
                }
            }

            resolve(mouseX, mouseY) {
                const headPos = this.spine.joints[0];
                const direction = vecSub({ x: mouseX, y: mouseY }, headPos);
                const dist = vecMag(direction);
                if (dist > 2) {
                    const moveSpeed = Math.min(dist * 0.3, 8);
                    this.spine.resolve(vecAdd(headPos, vecSetMag(direction, moveSpeed)));
                    this.initialized = true;
                }
                if (!this.initialized) return;
                for (let i = 0; i < this.legs.length; i++) {
                    const side = i % 2 === 0 ? 1 : -1;
                    const bodyIndex = i < 2 ? 3 : 7;
                    const angle = i < 2 ? Math.PI / 4 : Math.PI / 3;
                    const desiredPos = { x: this.getPosX(bodyIndex, angle * side, 70), y: this.getPosY(bodyIndex, angle * side, 70) };
                    if (vecDist(desiredPos, this.legTargets[i]) > 160) this.legTargets[i] = desiredPos;
                    const anchor = { x: this.getPosX(bodyIndex, Math.PI / 2 * side, -16), y: this.getPosY(bodyIndex, Math.PI / 2 * side, -16) };
                    this.legs[i].fabrikResolve(vecLerp(this.legs[i].joints[0], this.legTargets[i], 0.35), anchor);
                }
            }

            display(ctx, caughtBugs = []) {
                this.updateTongue();
                this.drawLegs(ctx);
                this.drawTongue(ctx, caughtBugs);
                this.drawBody(ctx);
                this.drawEyes(ctx);
                this.drawPatterns(ctx);
            }
            
            drawTongue(ctx, caughtBugs = []) {
                if (this.tongueOut <= 0) return;
                const headAngle = this.spine.angles[0];
                const headPos = this.spine.joints[0];
                const tongueBase = { x: headPos.x + Math.cos(headAngle) * 35, y: headPos.y + Math.sin(headAngle) * 35 };
                const tongueLength = 35 * this.tongueOut;
                const forkLength = 12 * this.tongueOut;
                const forkAngle = Math.PI / 8;
                const tongueMid = { x: tongueBase.x + Math.cos(headAngle) * tongueLength, y: tongueBase.y + Math.sin(headAngle) * tongueLength };
                const forkLeft = { x: tongueMid.x + Math.cos(headAngle - forkAngle) * forkLength, y: tongueMid.y + Math.sin(headAngle - forkAngle) * forkLength };
                const forkRight = { x: tongueMid.x + Math.cos(headAngle + forkAngle) * forkLength, y: tongueMid.y + Math.sin(headAngle + forkAngle) * forkLength };
                
                // ç»˜åˆ¶è¢«æŠ“ä½çš„å°è™«ï¼ˆåœ¨èˆŒå¤´åé¢ï¼‰
                for (const bug of caughtBugs) {
                    bug.draw(ctx, this);
                }
                
                ctx.strokeStyle = this.tongueColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(tongueBase.x, tongueBase.y); ctx.lineTo(tongueMid.x, tongueMid.y); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(forkLeft.x, forkLeft.y); ctx.lineTo(tongueMid.x, tongueMid.y); ctx.lineTo(forkRight.x, forkRight.y); ctx.stroke();
            }

            drawLegs(ctx) {
                for (let i = 0; i < this.legs.length; i++) {
                    const elbow = { ...this.legs[i].joints[1] };
                    const foot = this.legs[i].joints[0];
                    const shoulder = this.legs[i].joints[2];
                    const para = vecSub(foot, shoulder);
                    const perpNorm = vecSetMag({ x: -para.y, y: para.x }, 25);
                    if (i === 2) { elbow.x -= perpNorm.x; elbow.y -= perpNorm.y; }
                    else if (i === 3) { elbow.x += perpNorm.x; elbow.y += perpNorm.y; }
                    this.drawToePads(ctx, foot, elbow);
                }
                for (let i = 0; i < this.legs.length; i++) {
                    const shoulder = this.legs[i].joints[2];
                    const elbow = { ...this.legs[i].joints[1] };
                    const foot = this.legs[i].joints[0];
                    const para = vecSub(foot, shoulder);
                    const perpNorm = vecSetMag({ x: -para.y, y: para.x }, 25);
                    if (i === 2) { elbow.x -= perpNorm.x; elbow.y -= perpNorm.y; }
                    else if (i === 3) { elbow.x += perpNorm.x; elbow.y += perpNorm.y; }
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 28; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(shoulder.x, shoulder.y); ctx.quadraticCurveTo(elbow.x, elbow.y, foot.x, foot.y); ctx.stroke();
                    ctx.strokeStyle = this.legColor; ctx.lineWidth = 22;
                    ctx.beginPath(); ctx.moveTo(shoulder.x, shoulder.y); ctx.quadraticCurveTo(elbow.x, elbow.y, foot.x, foot.y); ctx.stroke();
                }
            }

            drawToePads(ctx, foot, elbow) {
                const angle = vecHeading(vecSub(foot, elbow));
                const toeSpread = Math.PI / 2.5;
                for (let j = 0; j < 4; j++) {
                    const toeAngle = angle - toeSpread / 2 + (toeSpread / 3) * j;
                    const toeStart = { x: foot.x + Math.cos(toeAngle) * 4, y: foot.y + Math.sin(toeAngle) * 4 };
                    const toeEnd = { x: foot.x + Math.cos(toeAngle) * 18, y: foot.y + Math.sin(toeAngle) * 18 };
                    ctx.strokeStyle = '#A8D9A7'; ctx.lineWidth = 8; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(toeStart.x, toeStart.y); ctx.lineTo(toeEnd.x, toeEnd.y); ctx.stroke();
                    const perpAngle = toeAngle + Math.PI / 2, offset = 4;
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(toeStart.x + Math.cos(perpAngle) * offset, toeStart.y + Math.sin(perpAngle) * offset);
                    ctx.lineTo(toeEnd.x + Math.cos(perpAngle) * offset, toeEnd.y + Math.sin(perpAngle) * offset); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(toeStart.x - Math.cos(perpAngle) * offset, toeStart.y - Math.sin(perpAngle) * offset);
                    ctx.lineTo(toeEnd.x - Math.cos(perpAngle) * offset, toeEnd.y - Math.sin(perpAngle) * offset); ctx.stroke();
                    ctx.beginPath(); ctx.arc(toeEnd.x, toeEnd.y, offset, toeAngle - Math.PI/2, toeAngle + Math.PI/2); ctx.stroke();
                }
            }

            drawBody(ctx) {
                const joints = this.spine.joints, angles = this.spine.angles;
                const headAngle = angles[0], headPos = joints[0];
                ctx.fillStyle = this.bodyColor; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4;
                ctx.beginPath();
                const headTip = { x: headPos.x + Math.cos(headAngle) * 45, y: headPos.y + Math.sin(headAngle) * 45 };
                const rightPoints = [], leftPoints = [];
                for (let i = 0; i < joints.length; i++) rightPoints.push({ x: this.getPosX(i, Math.PI / 2, 0), y: this.getPosY(i, Math.PI / 2, 0) });
                for (let i = joints.length - 1; i >= 0; i--) leftPoints.push({ x: this.getPosX(i, -Math.PI / 2, 0), y: this.getPosY(i, -Math.PI / 2, 0) });
                ctx.moveTo(rightPoints[0].x, rightPoints[0].y);
                for (let i = 1; i < rightPoints.length; i++) {
                    const prev = rightPoints[i - 1], curr = rightPoints[i];
                    ctx.quadraticCurveTo(prev.x, prev.y, (prev.x + curr.x) / 2, (prev.y + curr.y) / 2);
                }
                ctx.lineTo(rightPoints[rightPoints.length - 1].x, rightPoints[rightPoints.length - 1].y);
                ctx.lineTo(leftPoints[0].x, leftPoints[0].y);
                for (let i = 1; i < leftPoints.length; i++) {
                    const prev = leftPoints[i - 1], curr = leftPoints[i];
                    ctx.quadraticCurveTo(prev.x, prev.y, (prev.x + curr.x) / 2, (prev.y + curr.y) / 2);
                }
                const leftHead = leftPoints[leftPoints.length - 1], rightHead = rightPoints[0];
                const leftCtrl = { x: leftHead.x + Math.cos(headAngle) * 25, y: leftHead.y + Math.sin(headAngle) * 25 };
                const rightCtrl = { x: rightHead.x + Math.cos(headAngle) * 25, y: rightHead.y + Math.sin(headAngle) * 25 };
                ctx.bezierCurveTo(leftCtrl.x, leftCtrl.y, headTip.x, headTip.y, headTip.x, headTip.y);
                ctx.bezierCurveTo(headTip.x, headTip.y, rightCtrl.x, rightCtrl.y, rightHead.x, rightHead.y);
                ctx.closePath(); ctx.fill(); ctx.stroke();
            }

            drawEyes(ctx) {
                const headAngle = this.spine.angles[0], headPos = this.spine.joints[0];
                const eyeOffset = 30, eyeForward = 5;
                const leftEye = { x: headPos.x + Math.cos(headAngle) * eyeForward + Math.cos(headAngle - Math.PI/2) * eyeOffset,
                                  y: headPos.y + Math.sin(headAngle) * eyeForward + Math.sin(headAngle - Math.PI/2) * eyeOffset };
                const rightEye = { x: headPos.x + Math.cos(headAngle) * eyeForward + Math.cos(headAngle + Math.PI/2) * eyeOffset,
                                   y: headPos.y + Math.sin(headAngle) * eyeForward + Math.sin(headAngle + Math.PI/2) * eyeOffset };
                ctx.fillStyle = '#ffffff';
                ctx.beginPath(); ctx.arc(leftEye.x, leftEye.y, 12, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(rightEye.x, rightEye.y, 12, 0, Math.PI * 2); ctx.fill();
            }

            drawPatterns(ctx) {
                ctx.fillStyle = 'rgba(150, 210, 150, 0.5)';
                for (const i of [2, 4, 6, 8]) {
                    if (i < this.spine.joints.length) {
                        ctx.beginPath(); ctx.arc(this.spine.joints[i].x, this.spine.joints[i].y, this.bodyWidth[i] * 0.4, 0, Math.PI * 2); ctx.fill();
                    }
                }
                ctx.fillStyle = 'rgba(120, 180, 120, 0.4)';
                for (let i = 1; i < 8; i += 2) {
                    const spotSize = this.bodyWidth[i] * 0.25;
                    ctx.beginPath(); ctx.arc(this.getPosX(i, Math.PI / 2, -spotSize), this.getPosY(i, Math.PI / 2, -spotSize), spotSize, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(this.getPosX(i, -Math.PI / 2, -spotSize), this.getPosY(i, -Math.PI / 2, -spotSize), spotSize, 0, Math.PI * 2); ctx.fill();
                }
            }

            getPosX(i, angleOffset, lengthOffset) {
                return Math.round((this.spine.joints[i].x + Math.cos(this.spine.angles[i] + angleOffset) * (this.bodyWidth[i] + lengthOffset)) * 100) / 100;
            }
            getPosY(i, angleOffset, lengthOffset) {
                return Math.round((this.spine.joints[i].y + Math.sin(this.spine.angles[i] + angleOffset) * (this.bodyWidth[i] + lengthOffset)) * 100) / 100;
            }
        }

        // ==================== ä¸»ç¨‹åº ====================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementById('video');
        const statusElement = document.getElementById('status');
        const videoContainer = document.getElementById('video-container');
        
        let width, height, targetX, targetY, smoothTargetX, smoothTargetY, gecko;
        let handDetected = false;
        let lastHandTime = 0;
        const SMOOTH_FACTOR = 0.06; // é™ä½å¹³æ»‘å› å­ï¼Œæ›´å¹³æ»‘
        const IDLE_THRESHOLD = 120;
        let idleTimer = 0, idleTarget = null, idleActionTimer = 0;
        
        // é¢å¤–çš„å¹³æ»‘å±‚ - ç”¨äºè¿‡æ»¤æ‰‹éƒ¨è¿½è¸ªçš„æŠ–åŠ¨
        let rawTargetX, rawTargetY;
        let filteredTargetX, filteredTargetY;
        const RAW_SMOOTH = 0.15; // åŸå§‹è¾“å…¥çš„é¢„å¹³æ»‘
        
        // å°è™«ç³»ç»Ÿ
        let bugs = [];
        const MAX_BUGS = 5;
        const BUG_SPAWN_INTERVAL = 180; // æ¯3ç§’ç”Ÿæˆä¸€åª
        let bugSpawnTimer = 60;
        let score = 0;
        
        // è§†é¢‘æ˜¾ç¤ºåˆ‡æ¢
        function toggleVideo() {
            const btn = document.querySelector('.toggle-btn');
            if (videoContainer.style.display === 'none') {
                videoContainer.style.display = 'block';
                btn.textContent = 'éšè—æ‘„åƒå¤´';
            } else {
                videoContainer.style.display = 'none';
                btn.textContent = 'æ˜¾ç¤ºæ‘„åƒå¤´';
            }
        }
        
        function resize() { 
            width = window.innerWidth; 
            height = window.innerHeight; 
            canvas.width = width; 
            canvas.height = height; 
        }
        
        function init() {
            resize();
            gecko = new Gecko({ x: width / 2, y: height / 2 });
            targetX = smoothTargetX = width / 2;
            targetY = smoothTargetY = height / 2;
            rawTargetX = filteredTargetX = width / 2;
            rawTargetY = filteredTargetY = height / 2;
            
            // åˆå§‹åŒ–ä¸€äº›å°è™«
            bugs = [];
            for (let i = 0; i < 2; i++) {
                bugs.push(new Bug(width, height));
            }
            score = 0;
        }
        
        function generateIdleAction() {
            const headPos = gecko.spine.joints[0], headAngle = gecko.spine.angles[0];
            if (Math.random() < 0.5) {
                const swayAngle = headAngle + (Math.random() - 0.5) * Math.PI / 3;
                idleTarget = { x: headPos.x + Math.cos(swayAngle) * (30 + Math.random() * 20), y: headPos.y + Math.sin(swayAngle) * (30 + Math.random() * 20) };
            } else {
                const moveAngle = headAngle + (Math.random() - 0.5) * Math.PI / 2;
                idleTarget = { x: headPos.x + Math.cos(moveAngle) * (40 + Math.random() * 60), y: headPos.y + Math.sin(moveAngle) * (40 + Math.random() * 60) };
            }
            idleTarget.x = Math.max(100, Math.min(width - 100, idleTarget.x));
            idleTarget.y = Math.max(100, Math.min(height - 100, idleTarget.y));
            idleActionTimer = 30 + Math.random() * 90;
        }
        
        function animate() {
            ctx.fillStyle = '#282c34'; 
            ctx.fillRect(0, 0, width, height);
            drawGrid(ctx);
            
            // ========== å°è™«ç³»ç»Ÿ ==========
            // ç”Ÿæˆæ–°å°è™«
            bugSpawnTimer--;
            if (bugSpawnTimer <= 0 && bugs.filter(b => b.alive && !b.caught).length < MAX_BUGS) {
                bugs.push(new Bug(width, height));
                bugSpawnTimer = BUG_SPAWN_INTERVAL;
            }
            
            // æ›´æ–°å°è™«
            for (const bug of bugs) {
                bug.update();
            }
            
            // ç§»é™¤å·²è¢«åƒæ‰çš„å°è™«
            const eatenCount = bugs.filter(b => !b.alive).length;
            score += eatenCount;
            bugs = bugs.filter(b => b.alive);
            
            // ç»˜åˆ¶æœªè¢«æŠ“çš„å°è™«ï¼ˆåœ¨å£è™ä¸‹é¢ï¼‰
            for (const bug of bugs) {
                if (!bug.caught) {
                    bug.draw(ctx, gecko);
                }
            }
            
            // ========== å£è™ç³»ç»Ÿ ==========
            // æ£€æŸ¥æ˜¯å¦æœ‰æ‰‹éƒ¨æ£€æµ‹
            const now = Date.now();
            if (now - lastHandTime > 500) {
                handDetected = false;
                idleTimer++;
            } else {
                idleTimer = 0;
                idleTarget = null;
            }
            
            let currentTargetX = targetX, currentTargetY = targetY;
            
            // ç©ºé—²åŠ¨ç”»
            if (idleTimer > IDLE_THRESHOLD) {
                idleActionTimer--;
                if (idleActionTimer <= 0 || !idleTarget) generateIdleAction();
                if (idleTarget) { 
                    currentTargetX = idleTarget.x; 
                    currentTargetY = idleTarget.y; 
                }
            } else {
                // ç¬¬ä¸€å±‚å¹³æ»‘ï¼šè¿‡æ»¤æ‰‹éƒ¨è¿½è¸ªçš„åŸå§‹æŠ–åŠ¨
                filteredTargetX += (rawTargetX - filteredTargetX) * RAW_SMOOTH;
                filteredTargetY += (rawTargetY - filteredTargetY) * RAW_SMOOTH;
                currentTargetX = filteredTargetX;
                currentTargetY = filteredTargetY;
            }
            
            // ç¬¬äºŒå±‚å¹³æ»‘ï¼šå£è™è·Ÿéšçš„å¹³æ»‘ç§»åŠ¨
            const factor = idleTimer > IDLE_THRESHOLD ? 0.08 : SMOOTH_FACTOR;
            smoothTargetX += (currentTargetX - smoothTargetX) * factor;
            smoothTargetY += (currentTargetY - smoothTargetY) * factor;
            
            gecko.resolve(smoothTargetX, smoothTargetY);
            
            // æ£€æµ‹æ•é£Ÿ
            gecko.checkForPrey(bugs);
            
            // è·å–è¢«æŠ“ä½çš„å°è™«ï¼ˆç”¨äºåœ¨èˆŒå¤´å¤„ç»˜åˆ¶ï¼‰
            const caughtBugs = bugs.filter(b => b.caught);
            
            gecko.display(ctx, caughtBugs);
            
            // ç»˜åˆ¶åˆ†æ•°
            drawScore(ctx);
            
            // ç»˜åˆ¶æ‰‹éƒ¨ç›®æ ‡æŒ‡ç¤ºå™¨
            if (handDetected) {
                drawHandIndicator(ctx, targetX, targetY);
            }
            
            requestAnimationFrame(animate);
        }
        
        function drawGrid(ctx) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; 
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 50) { 
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); 
            }
            for (let y = 0; y < height; y += 50) { 
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); 
            }
        }
        
        // ç»˜åˆ¶åˆ†æ•°
        function drawScore(ctx) {
            if (score > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '16px "Segoe UI", sans-serif';
                ctx.fillText(`ğŸª² å·²æ•é£Ÿ: ${score}`, 20, height - 50);
            }
        }
        
        // ç»˜åˆ¶æ‰‹éƒ¨ä½ç½®æŒ‡ç¤ºå™¨
        function drawHandIndicator(ctx, x, y) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x - 30, y);
            ctx.lineTo(x - 10, y);
            ctx.moveTo(x + 10, y);
            ctx.lineTo(x + 30, y);
            ctx.moveTo(x, y - 30);
            ctx.lineTo(x, y - 10);
            ctx.moveTo(x, y + 10);
            ctx.lineTo(x, y + 30);
            ctx.stroke();
        }
        
        // ==================== MediaPipe æ‰‹éƒ¨è¿½è¸ª ====================
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // å–ç¬¬ä¸€åªæ‰‹çš„é£ŸæŒ‡æŒ‡å°– (ç´¢å¼•8)
                const landmarks = results.multiHandLandmarks[0];
                const indexFingerTip = landmarks[8];
                
                // è½¬æ¢åæ ‡ï¼ˆé•œåƒç¿»è½¬ + ç¼©æ”¾åˆ°ç”»å¸ƒï¼‰
                rawTargetX = (1 - indexFingerTip.x) * width;  // é•œåƒ
                rawTargetY = indexFingerTip.y * height;
                
                // åŒæ—¶æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆç”¨äºç»˜åˆ¶æŒ‡ç¤ºå™¨ï¼‰
                targetX = rawTargetX;
                targetY = rawTargetY;
                
                handDetected = true;
                lastHandTime = Date.now();
            }
        }
        
        async function setupCamera() {
            try {
                // åˆå§‹åŒ– MediaPipe Hands
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandResults);
                
                // åˆå§‹åŒ–æ‘„åƒå¤´
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });
                
                await camera.start();
                
                statusElement.textContent = 'âœ“ æ‰‹éƒ¨è¿½è¸ªå·²å°±ç»ª';
                statusElement.className = 'status ready';
                
                // 3ç§’åéšè—çŠ¶æ€æç¤º
                setTimeout(() => {
                    statusElement.style.opacity = '0';
                    statusElement.style.transition = 'opacity 0.5s';
                }, 3000);
                
            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                statusElement.textContent = 'âœ— æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œä½¿ç”¨é¼ æ ‡æ¨¡å¼';
                statusElement.className = 'status error';
                
                // å›é€€åˆ°é¼ æ ‡æ¨¡å¼
                enableMouseFallback();
            }
        }
        
        // é¼ æ ‡/è§¦æ‘¸åå¤‡æ–¹æ¡ˆ
        function enableMouseFallback() {
            canvas.addEventListener('mousemove', (e) => { 
                rawTargetX = e.clientX; 
                rawTargetY = e.clientY;
                targetX = e.clientX;
                targetY = e.clientY;
                handDetected = true;
                lastHandTime = Date.now();
            });
            canvas.addEventListener('touchmove', (e) => { 
                e.preventDefault(); 
                rawTargetX = e.touches[0].clientX; 
                rawTargetY = e.touches[0].clientY;
                targetX = e.touches[0].clientX;
                targetY = e.touches[0].clientY;
                handDetected = true;
                lastHandTime = Date.now();
            });
            
            videoContainer.style.display = 'none';
            document.querySelector('.toggle-btn').style.display = 'none';
        }
        
        // å¯åŠ¨
        window.addEventListener('resize', resize);
        init();
        animate();
        setupCamera();
    </script>
</body>
</html>
